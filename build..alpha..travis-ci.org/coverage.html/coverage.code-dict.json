{"/home/travis/build/npmtest/node-npmtest-pathfinding/test.js":"/* istanbul instrument in package npmtest_pathfinding */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pathfinding/lib.npmtest_pathfinding.js":"/* istanbul instrument in package npmtest_pathfinding */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pathfinding = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pathfinding = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pathfinding/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pathfinding && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pathfinding */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pathfinding\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pathfinding.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pathfinding.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pathfinding.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pathfinding.__dirname + '/lib.npmtest_pathfinding.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/index.js":"module.exports = require('./src/PathFinding');\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/PathFinding.js":"module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/core/Node.js":"/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/core/Grid.js":"var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // ↑\r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // →\r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // ↓\r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // ←\r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // ↖\r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // ↗\r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // ↘\r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // ↙\r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/core/DiagonalMovement.js":"var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/core/Util.js":"/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/core/Heuristic.js":"/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/AStarFinder.js":"var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/BestFirstFinder.js":"var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/BreadthFirstFinder.js":"var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/DijkstraFinder.js":"var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/BiAStarFinder.js":"var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/BiBestFirstFinder.js":"var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js":"var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/BiDijkstraFinder.js":"var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/IDAStarFinder.js":"var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/JumpPointFinder.js":"/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js":"/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/JumpPointFinderBase.js":"/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js":"/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js":"/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js":"/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/gulpfile.js":"var gulp = require('gulp'),\r\n    uglify = require('gulp-uglify'),\r\n    rename = require('gulp-rename'),\r\n    browserify = require('gulp-browserify'),\r\n    concat = require('gulp-concat'),\r\n    mocha = require('gulp-mocha'),\r\n    shell = require('shelljs'),\r\n    del = require('del'),\r\n    jshint = require('gulp-jshint'),\r\n    stylish = require('jshint-stylish'),\r\n    semver = require('semver'),\r\n    jsonfile = require('jsonfile'),\r\n    inquirer = require(\"inquirer\"),\r\n    fs = require('fs');\r\n\r\ngulp.task('clean', function(cb) {\r\n    del('lib/**/*.*', cb);\r\n});\r\n\r\ngulp.task('browserify', ['clean'], function(cb) {\r\n    return gulp.src('./src/PathFinding.js')\r\n    .pipe(browserify({ standalone: 'PF' }))\r\n    .pipe(rename('pathfinding-browserified.js'))\r\n    .pipe(gulp.dest('./lib/'), cb);\r\n});\r\n\r\ngulp.task('uglify', ['browserify'], function(cb) {\r\n    return gulp.src('./lib/pathfinding-browserified.js')\r\n    .pipe(uglify())\r\n    .pipe(rename('pathfinding-browser.min.js'))\r\n    .pipe(gulp.dest('./lib/'), cb);\r\n});\r\n\r\ngulp.task('scripts', ['clean', 'browserify', 'uglify'], function(cb) {\r\n    return gulp.src(['./src/banner', './lib/pathfinding-browserified.js'])\r\n    .pipe(concat('pathfinding-browser.js'))\r\n    .pipe(gulp.dest('./lib/'), cb);\r\n});\r\n\r\ngulp.task('compile', ['scripts'], function() {\r\n    del('./lib/pathfinding-browserified.js');\r\n});\r\n\r\ngulp.task('test', function () {\r\n    return gulp.src('./test/**/*.js', {read: false})\r\n        .pipe(mocha({reporter: 'spec', bail: true, globals: { should: require('should') }}));\r\n});\r\n\r\ngulp.task('bench', function() {\r\n    shell.exec('node benchmark/benchmark.js');\r\n});\r\n\r\ngulp.task('lint', function() {\r\n  return gulp.src('./src/**/*.js')\r\n    .pipe(jshint())\r\n    .pipe(jshint.reporter(stylish))\r\n    .pipe(jshint.reporter('fail'));\r\n});\r\n\r\ngulp.task('release', ['compile'], function(cb) {\r\n  inquirer.prompt({\r\n      type: 'list',\r\n      name: 'bumpType',\r\n      message: 'Which version do you want to bump?',\r\n      choices: ['patch', 'minor', 'major'],\r\n      //default is patch\r\n      default: 0\r\n    }, function (result) {\r\n      var f = jsonfile.readFileSync('./package.json');\r\n      f.version = semver.inc(f.version, result.bumpType);\r\n      jsonfile.writeFileSync('./package.json', f);\r\n\r\n      shell.exec('git add .');\r\n      shell.exec('git commit -m \"Bumping version to ' + f.version + '\"');\r\n      shell.exec('git push origin master');\r\n      shell.exec('git tag -a ' + f.version + ' -m \"Creating tag for version ' + f.version + '\"');\r\n      shell.exec('git push origin ' + f.version);\r\n      shell.exec('npm publish');\r\n\r\n      shell.exec('git clone https://github.com/imor/pathfinding-bower.git release');\r\n      process.chdir('release');\r\n      fs.writeFileSync('pathfinding-browser.js', fs.readFileSync('../lib/pathfinding-browser.js'));\r\n      fs.writeFileSync('pathfinding-browser.min.js', fs.readFileSync('../lib/pathfinding-browser.min.js'));\r\n\r\n      f = jsonfile.readFileSync('bower.json');\r\n      f.version = semver.inc(f.version, result.bumpType);\r\n      jsonfile.writeFileSync('bower.json', f);\r\n\r\n      shell.exec('git add .');\r\n      shell.exec('git commit -m \"Bumping version to ' + f.version + '\"');\r\n      shell.exec('git push origin master');\r\n      shell.exec('git tag -a ' + f.version + ' -m \"Creating tag for version ' + f.version + '\"');\r\n      shell.exec('git push origin ' + f.version);\r\n\r\n      process.chdir('../');\r\n      del('release');\r\n      del('lib/**/*.*', cb);\r\n    });\r\n});\r\n\r\ngulp.task('default', ['lint', 'test', 'compile'], function() {\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/benchmark/benchmark.js":"#!/usr/bin/env node\r\n\r\nvar colors    = require('colors');\r\nvar PF        = require('..');\r\nvar parseMap  = require('./parse_map').parse;\r\nvar parseScen = require('./parse_scen').parse;\r\nvar testCases = require('./test_cases');\r\nvar path      = require('path');\r\n\r\nfunction profile(callback) {\r\n  var startTime = Date.now();\r\n  ret = callback();\r\n  var endTime = Date.now();\r\n  return {\r\n    returnValue: ret,\r\n    time: endTime - startTime\r\n  };\r\n}\r\n\r\n/**\r\n * @param {object} opt\r\n * @param {string} opt.header\r\n * @param {string} opt.footer\r\n * @param {PF.*Finder} opt.finder\r\n * @param {PF.Grid} opt.grid\r\n * @param {number} opt.startX\r\n * @param {number} opt.startY\r\n * @param {number} opt.endX\r\n * @param {number} opt.endY\r\n */\r\nfunction benchmark(opt) {\r\n  var result = profile(function() {\r\n    return opt.finder.findPath(\r\n      opt.startX,\r\n      opt.startY,\r\n      opt.endX,\r\n      opt.endY,\r\n      opt.grid\r\n    );\r\n  });\r\n  var fields = [\r\n    opt.header,\r\n    (''+result.time + 'ms').yellow,\r\n    'length' , formatFloat(PF.Util.pathLength(result.returnValue)),\r\n    opt.footer,\r\n  ];\r\n  console.log(fields.join(' '));\r\n}\r\n\r\nfunction formatFloat(float) {\r\n  return Math.round(float * 1000) / 1000;\r\n}\r\n\r\nfunction map2grid(map) {\r\n  return new PF.Grid(map.width, map.height, map.grid);\r\n}\r\n\r\ntestCases.forEach(function(test) {\r\n  var grid = map2grid(parseMap(path.join(__dirname, test.map)));\r\n  var scens = parseScen(path.join(__dirname, test.scen)).scenarios;\r\n  var select = test.select;\r\n\r\n  select.forEach(function(id) {\r\n    var scen = scens[id];\r\n    var result = benchmark({\r\n      header: 'AStarFinder',\r\n      finder: new PF.AStarFinder({allowDiagonal: true}),\r\n      grid: grid,\r\n      startX: scen.startX,\r\n      startY: scen.startY,\r\n      endX: scen.endX,\r\n      endY: scen.endY,\r\n      footer: '(optimal: '.grey + (''+scen.length).green + ')'.grey\r\n    });\r\n  });\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/benchmark/parse_map.js":"#!/usr/bin/env node\r\n\r\n/**\r\n * Convert the `map` files into json\r\n * \r\n * All maps begin with the lines:\r\n * \r\n *     type octile\r\n *     height x\r\n *     width y\r\n *     map\r\n * \r\n * where x and y are the repsective height and width of the map.\r\n * \r\n * The map data is store as an ASCII grid. The following characters are possible:\r\n * \r\n *     . - passable terrain\r\n *     G - passable terrain\r\n *     @ - out of bounds\r\n *     O - out of bounds\r\n *     T - trees (unpassable)\r\n *     S - swamp (passable from regular terrain)\r\n *     W - water (traversable, but not passable from terrain)\r\n * \r\n */\r\n\r\n/**\r\n * Implementation note:\r\n * For convenience, only '.' and 'G' are interpreted as walkable.\r\n */\r\n\r\nvar fs = require('fs');\r\nvar endOfLine = require('os').EOL;\r\n\r\nfunction parse(filename) {\r\n  var content = fs.readFileSync(filename).toString();\r\n  var lines = content.split(endOfLine);\r\n  return {\r\n    height : parseInt(lines[1].split(' ')[1]),\r\n    width  : parseInt(lines[2].split(' ')[1]),\r\n    grid   : parseGrid(lines.slice(4)),\r\n  };\r\n}\r\nexports.parse = parse;\r\n\r\nfunction parseGrid(lines) {\r\n  var grid = [];\r\n  lines.forEach(function(line) {\r\n    if (!line.length) {\r\n      return;\r\n    }\r\n    var row = [];\r\n    line.split('').forEach(function(char) {\r\n      row.push(char in { '.': 1, 'G': 1 } ? 0 : 1);\r\n    });\r\n    grid.push(row);\r\n  });\r\n  return grid;\r\n}\r\n\r\nfunction splitext(filename) {\r\n  var index = filename.lastIndexOf('.');\r\n  if (index < 0) {\r\n    return [filename, ''];\r\n  } else {\r\n    return [filename.substr(0, index), filename.substr(index)];\r\n  }\r\n}\r\n\r\nfunction main(argv) {\r\n  var filename = argv[2];\r\n  var obj = parse(filename);\r\n  var root = splitext(filename)[0];\r\n  fs.writeFileSync(root + '.json', JSON.stringify(obj));\r\n}\r\n\r\nif (!module.parent) {\r\n  main(process.argv);\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/benchmark/parse_scen.js":"#!/usr/bin/env node\r\n\r\n/**\r\n * The scenario files have the following format.\r\n * The begin with the text \"version x.x\". This document describes version 1.0. \r\n * The trailing 0 is optional.\r\n *\r\n * Each line of a scenario has 9 fields:\r\n *\r\n * Bucket\r\n * map \r\n * map width\r\n * map height \r\n * start x-coordinate\r\n * start y-coordinate\r\n * goal x-coordinate\r\n * goal y-coordinate\r\n * optimal length\r\n */\r\n\r\nvar fs = require('fs');\r\n\r\nfunction parse(filename) {\r\n  var content = fs.readFileSync(filename).toString();\r\n  var lines = content.split('\\n');\r\n  var version = lines[1].split(/\\s+/);\r\n  return {\r\n    version: version,\r\n    scenarios: lines.slice(1, lines.length - 1).map(parseLine)\r\n  };\r\n}\r\n\r\nfunction parseLine(line) {\r\n  var fields = line.split(/\\s+/);\r\n  return {\r\n    bucket: parseInt(fields[0]),\r\n    map: fields[1],\r\n    width: parseInt(fields[2]),\r\n    height: parseInt(fields[3]),\r\n    startX: parseInt(fields[4]),\r\n    startY: parseInt(fields[5]),\r\n    endX: parseInt(fields[6]),\r\n    endY: parseInt(fields[7]),\r\n    length: parseFloat(fields[8])\r\n  };\r\n}\r\n\r\nexports.parse = parse;\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/visual/js/controller.js":"/**\r\n * The visualization controller will works as a state machine.\r\n * See files under the `doc` folder for transition descriptions.\r\n * See https://github.com/jakesgordon/javascript-state-machine\r\n * for the document of the StateMachine module.\r\n */\r\nvar Controller = StateMachine.create({\r\n    initial: 'none',\r\n    events: [\r\n        {\r\n            name: 'init',\r\n            from: 'none',\r\n            to:   'ready'\r\n        },\r\n        {\r\n            name: 'search',\r\n            from: 'starting',\r\n            to:   'searching'\r\n        },\r\n        {\r\n            name: 'pause',\r\n            from: 'searching',\r\n            to:   'paused'\r\n        },\r\n        {\r\n            name: 'finish',\r\n            from: 'searching',\r\n            to:   'finished'\r\n        },\r\n        {\r\n            name: 'resume',\r\n            from: 'paused',\r\n            to:   'searching'\r\n        },\r\n        {\r\n            name: 'cancel',\r\n            from: 'paused',\r\n            to:   'ready'\r\n        },\r\n        {\r\n            name: 'modify',\r\n            from: 'finished',\r\n            to:   'modified'\r\n        },\r\n        {\r\n            name: 'reset',\r\n            from: '*',\r\n            to:   'ready'\r\n        },\r\n        {\r\n            name: 'clear',\r\n            from: ['finished', 'modified'],\r\n            to:   'ready'\r\n        },\r\n        {\r\n            name: 'start',\r\n            from: ['ready', 'modified', 'restarting'],\r\n            to:   'starting'\r\n        },\r\n        {\r\n            name: 'restart',\r\n            from: ['searching', 'finished'],\r\n            to:   'restarting'\r\n        },\r\n        {\r\n            name: 'dragStart',\r\n            from: ['ready', 'finished'],\r\n            to:   'draggingStart'\r\n        },\r\n        {\r\n            name: 'dragEnd',\r\n            from: ['ready', 'finished'],\r\n            to:   'draggingEnd'\r\n        },\r\n        {\r\n            name: 'drawWall',\r\n            from: ['ready', 'finished'],\r\n            to:   'drawingWall'\r\n        },\r\n        {\r\n            name: 'eraseWall',\r\n            from: ['ready', 'finished'],\r\n            to:   'erasingWall'\r\n        },\r\n        {\r\n            name: 'rest',\r\n            from: ['draggingStart', 'draggingEnd', 'drawingWall', 'erasingWall'],\r\n            to  : 'ready'\r\n        },\r\n    ],\r\n});\r\n\r\n$.extend(Controller, {\r\n    gridSize: [64, 36], // number of nodes horizontally and vertically\r\n    operationsPerSecond: 300,\r\n\r\n    /**\r\n     * Asynchronous transition from `none` state to `ready` state.\r\n     */\r\n    onleavenone: function() {\r\n        var numCols = this.gridSize[0],\r\n            numRows = this.gridSize[1];\r\n\r\n        this.grid = new PF.Grid(numCols, numRows);\r\n\r\n        View.init({\r\n            numCols: numCols,\r\n            numRows: numRows\r\n        });\r\n        View.generateGrid(function() {\r\n            Controller.setDefaultStartEndPos();\r\n            Controller.bindEvents();\r\n            Controller.transition(); // transit to the next state (ready)\r\n        });\r\n\r\n        this.$buttons = $('.control_button');\r\n\r\n        this.hookPathFinding();\r\n\r\n        return StateMachine.ASYNC;\r\n        // => ready\r\n    },\r\n    ondrawWall: function(event, from, to, gridX, gridY) {\r\n        this.setWalkableAt(gridX, gridY, false);\r\n        // => drawingWall\r\n    },\r\n    oneraseWall: function(event, from, to, gridX, gridY) {\r\n        this.setWalkableAt(gridX, gridY, true);\r\n        // => erasingWall\r\n    },\r\n    onsearch: function(event, from, to) {\r\n        var grid,\r\n            timeStart, timeEnd,\r\n            finder = Panel.getFinder();\r\n\r\n        timeStart = window.performance ? performance.now() : Date.now();\r\n        grid = this.grid.clone();\r\n        this.path = finder.findPath(\r\n            this.startX, this.startY, this.endX, this.endY, grid\r\n        );\r\n        this.operationCount = this.operations.length;\r\n        timeEnd = window.performance ? performance.now() : Date.now();\r\n        this.timeSpent = (timeEnd - timeStart).toFixed(4);\r\n\r\n        this.loop();\r\n        // => searching\r\n    },\r\n    onrestart: function() {\r\n        // When clearing the colorized nodes, there may be\r\n        // nodes still animating, which is an asynchronous procedure.\r\n        // Therefore, we have to defer the `abort` routine to make sure\r\n        // that all the animations are done by the time we clear the colors.\r\n        // The same reason applies for the `onreset` event handler.\r\n        setTimeout(function() {\r\n            Controller.clearOperations();\r\n            Controller.clearFootprints();\r\n            Controller.start();\r\n        }, View.nodeColorizeEffect.duration * 1.2);\r\n        // => restarting\r\n    },\r\n    onpause: function(event, from, to) {\r\n        // => paused\r\n    },\r\n    onresume: function(event, from, to) {\r\n        this.loop();\r\n        // => searching\r\n    },\r\n    oncancel: function(event, from, to) {\r\n        this.clearOperations();\r\n        this.clearFootprints();\r\n        // => ready\r\n    },\r\n    onfinish: function(event, from, to) {\r\n        View.showStats({\r\n            pathLength: PF.Util.pathLength(this.path),\r\n            timeSpent:  this.timeSpent,\r\n            operationCount: this.operationCount,\r\n        });\r\n        View.drawPath(this.path);\r\n        // => finished\r\n    },\r\n    onclear: function(event, from, to) {\r\n        this.clearOperations();\r\n        this.clearFootprints();\r\n        // => ready\r\n    },\r\n    onmodify: function(event, from, to) {\r\n        // => modified\r\n    },\r\n    onreset: function(event, from, to) {\r\n        setTimeout(function() {\r\n            Controller.clearOperations();\r\n            Controller.clearAll();\r\n            Controller.buildNewGrid();\r\n        }, View.nodeColorizeEffect.duration * 1.2);\r\n        // => ready\r\n    },\r\n\r\n    /**\r\n     * The following functions are called on entering states.\r\n     */\r\n\r\n    onready: function() {\r\n        console.log('=> ready');\r\n        this.setButtonStates({\r\n            id: 1,\r\n            text: 'Start Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.start, this),\r\n        }, {\r\n            id: 2,\r\n            text: 'Pause Search',\r\n            enabled: false,\r\n        }, {\r\n            id: 3,\r\n            text: 'Clear Walls',\r\n            enabled: true,\r\n            callback: $.proxy(this.reset, this),\r\n        });\r\n        // => [starting, draggingStart, draggingEnd, drawingStart, drawingEnd]\r\n    },\r\n    onstarting: function(event, from, to) {\r\n        console.log('=> starting');\r\n        // Clears any existing search progress\r\n        this.clearFootprints();\r\n        this.setButtonStates({\r\n            id: 2,\r\n            enabled: true,\r\n        });\r\n        this.search();\r\n        // => searching\r\n    },\r\n    onsearching: function() {\r\n        console.log('=> searching');\r\n        this.setButtonStates({\r\n            id: 1,\r\n            text: 'Restart Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.restart, this),\r\n        }, {\r\n            id: 2,\r\n            text: 'Pause Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.pause, this),\r\n        });\r\n        // => [paused, finished]\r\n    },\r\n    onpaused: function() {\r\n        console.log('=> paused');\r\n        this.setButtonStates({\r\n            id: 1,\r\n            text: 'Resume Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.resume, this),\r\n        }, {\r\n            id: 2,\r\n            text: 'Cancel Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.cancel, this),\r\n        });\r\n        // => [searching, ready]\r\n    },\r\n    onfinished: function() {\r\n        console.log('=> finished');\r\n        this.setButtonStates({\r\n            id: 1,\r\n            text: 'Restart Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.restart, this),\r\n        }, {\r\n            id: 2,\r\n            text: 'Clear Path',\r\n            enabled: true,\r\n            callback: $.proxy(this.clear, this),\r\n        });\r\n    },\r\n    onmodified: function() {\r\n        console.log('=> modified');\r\n        this.setButtonStates({\r\n            id: 1,\r\n            text: 'Start Search',\r\n            enabled: true,\r\n            callback: $.proxy(this.start, this),\r\n        }, {\r\n            id: 2,\r\n            text: 'Clear Path',\r\n            enabled: true,\r\n            callback: $.proxy(this.clear, this),\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Define setters and getters of PF.Node, then we can get the operations\r\n     * of the pathfinding.\r\n     */\r\n    hookPathFinding: function() {\r\n\r\n        PF.Node.prototype = {\r\n            get opened() {\r\n                return this._opened;\r\n            },\r\n            set opened(v) {\r\n                this._opened = v;\r\n                Controller.operations.push({\r\n                    x: this.x,\r\n                    y: this.y,\r\n                    attr: 'opened',\r\n                    value: v\r\n                });\r\n            },\r\n            get closed() {\r\n                return this._closed;\r\n            },\r\n            set closed(v) {\r\n                this._closed = v;\r\n                Controller.operations.push({\r\n                    x: this.x,\r\n                    y: this.y,\r\n                    attr: 'closed',\r\n                    value: v\r\n                });\r\n            },\r\n            get tested() {\r\n                return this._tested;\r\n            },\r\n            set tested(v) {\r\n                this._tested = v;\r\n                Controller.operations.push({\r\n                    x: this.x,\r\n                    y: this.y,\r\n                    attr: 'tested',\r\n                    value: v\r\n                });\r\n            },\r\n        };\r\n\r\n        this.operations = [];\r\n    },\r\n    bindEvents: function() {\r\n        $('#draw_area').mousedown($.proxy(this.mousedown, this));\r\n        $(window)\r\n            .mousemove($.proxy(this.mousemove, this))\r\n            .mouseup($.proxy(this.mouseup, this));\r\n    },\r\n    loop: function() {\r\n        var interval = 1000 / this.operationsPerSecond;\r\n        (function loop() {\r\n            if (!Controller.is('searching')) {\r\n                return;\r\n            }\r\n            Controller.step();\r\n            setTimeout(loop, interval);\r\n        })();\r\n    },\r\n    step: function() {\r\n        var operations = this.operations,\r\n            op, isSupported;\r\n\r\n        do {\r\n            if (!operations.length) {\r\n                this.finish(); // transit to `finished` state\r\n                return;\r\n            }\r\n            op = operations.shift();\r\n            isSupported = View.supportedOperations.indexOf(op.attr) !== -1;\r\n        } while (!isSupported);\r\n\r\n        View.setAttributeAt(op.x, op.y, op.attr, op.value);\r\n    },\r\n    clearOperations: function() {\r\n        this.operations = [];\r\n    },\r\n    clearFootprints: function() {\r\n        View.clearFootprints();\r\n        View.clearPath();\r\n    },\r\n    clearAll: function() {\r\n        this.clearFootprints();\r\n        View.clearBlockedNodes();\r\n    },\r\n    buildNewGrid: function() {\r\n        this.grid = new PF.Grid(this.gridSize[0], this.gridSize[1]);\r\n    },\r\n    mousedown: function (event) {\r\n        var coord = View.toGridCoordinate(event.pageX, event.pageY),\r\n            gridX = coord[0],\r\n            gridY = coord[1],\r\n            grid  = this.grid;\r\n\r\n        if (this.can('dragStart') && this.isStartPos(gridX, gridY)) {\r\n            this.dragStart();\r\n            return;\r\n        }\r\n        if (this.can('dragEnd') && this.isEndPos(gridX, gridY)) {\r\n            this.dragEnd();\r\n            return;\r\n        }\r\n        if (this.can('drawWall') && grid.isWalkableAt(gridX, gridY)) {\r\n            this.drawWall(gridX, gridY);\r\n            return;\r\n        }\r\n        if (this.can('eraseWall') && !grid.isWalkableAt(gridX, gridY)) {\r\n            this.eraseWall(gridX, gridY);\r\n        }\r\n    },\r\n    mousemove: function(event) {\r\n        var coord = View.toGridCoordinate(event.pageX, event.pageY),\r\n            grid = this.grid,\r\n            gridX = coord[0],\r\n            gridY = coord[1];\r\n\r\n        if (this.isStartOrEndPos(gridX, gridY)) {\r\n            return;\r\n        }\r\n\r\n        switch (this.current) {\r\n        case 'draggingStart':\r\n            if (grid.isWalkableAt(gridX, gridY)) {\r\n                this.setStartPos(gridX, gridY);\r\n            }\r\n            break;\r\n        case 'draggingEnd':\r\n            if (grid.isWalkableAt(gridX, gridY)) {\r\n                this.setEndPos(gridX, gridY);\r\n            }\r\n            break;\r\n        case 'drawingWall':\r\n            this.setWalkableAt(gridX, gridY, false);\r\n            break;\r\n        case 'erasingWall':\r\n            this.setWalkableAt(gridX, gridY, true);\r\n            break;\r\n        }\r\n    },\r\n    mouseup: function(event) {\r\n        if (Controller.can('rest')) {\r\n            Controller.rest();\r\n        }\r\n    },\r\n    setButtonStates: function() {\r\n        $.each(arguments, function(i, opt) {\r\n            var $button = Controller.$buttons.eq(opt.id - 1);\r\n            if (opt.text) {\r\n                $button.text(opt.text);\r\n            }\r\n            if (opt.callback) {\r\n                $button\r\n                    .unbind('click')\r\n                    .click(opt.callback);\r\n            }\r\n            if (opt.enabled === undefined) {\r\n                return;\r\n            } else if (opt.enabled) {\r\n                $button.removeAttr('disabled');\r\n            } else {\r\n                $button.attr({ disabled: 'disabled' });\r\n            }\r\n        });\r\n    },\r\n    /**\r\n     * When initializing, this method will be called to set the positions\r\n     * of start node and end node.\r\n     * It will detect user's display size, and compute the best positions.\r\n     */\r\n    setDefaultStartEndPos: function() {\r\n        var width, height,\r\n            marginRight, availWidth,\r\n            centerX, centerY,\r\n            endX, endY,\r\n            nodeSize = View.nodeSize;\r\n\r\n        width  = $(window).width();\r\n        height = $(window).height();\r\n\r\n        marginRight = $('#algorithm_panel').width();\r\n        availWidth = width - marginRight;\r\n\r\n        centerX = Math.ceil(availWidth / 2 / nodeSize);\r\n        centerY = Math.floor(height / 2 / nodeSize);\r\n\r\n        this.setStartPos(centerX - 5, centerY);\r\n        this.setEndPos(centerX + 5, centerY);\r\n    },\r\n    setStartPos: function(gridX, gridY) {\r\n        this.startX = gridX;\r\n        this.startY = gridY;\r\n        View.setStartPos(gridX, gridY);\r\n    },\r\n    setEndPos: function(gridX, gridY) {\r\n        this.endX = gridX;\r\n        this.endY = gridY;\r\n        View.setEndPos(gridX, gridY);\r\n    },\r\n    setWalkableAt: function(gridX, gridY, walkable) {\r\n        this.grid.setWalkableAt(gridX, gridY, walkable);\r\n        View.setAttributeAt(gridX, gridY, 'walkable', walkable);\r\n    },\r\n    isStartPos: function(gridX, gridY) {\r\n        return gridX === this.startX && gridY === this.startY;\r\n    },\r\n    isEndPos: function(gridX, gridY) {\r\n        return gridX === this.endX && gridY === this.endY;\r\n    },\r\n    isStartOrEndPos: function(gridX, gridY) {\r\n        return this.isStartPos(gridX, gridY) || this.isEndPos(gridX, gridY);\r\n    },\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/visual/js/main.js":"$(document).ready(function() {\r\n    if (!Raphael.svg) {\r\n        window.location = './notsupported.html';\r\n    }\r\n\r\n    // suppress select events\r\n    $(window).bind('selectstart', function(event) {\r\n        event.preventDefault();\r\n    });\r\n\r\n    // initialize visualization\r\n    Panel.init();\r\n    Controller.init();\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/visual/js/panel.js":"/**\r\n * The control panel.\r\n */\r\nvar Panel = {\r\n    init: function() {\r\n        var $algo = $('#algorithm_panel');\r\n\r\n        $('.panel').draggable();\r\n        $('.accordion').accordion({\r\n            collapsible: false,\r\n        });\r\n        $('.option_label').click(function() {\r\n            $(this).prev().click();\r\n        });\r\n        $('#hide_instructions').click(function() {\r\n            $('#instructions_panel').slideUp();\r\n        });\r\n        $('#play_panel').css({\r\n            top: $algo.offset().top + $algo.outerHeight() + 20\r\n        });\r\n        $('#button2').attr('disabled', 'disabled');\r\n    },\r\n    /**\r\n     * Get the user selected path-finder.\r\n     * TODO: clean up this messy code.\r\n     */\r\n    getFinder: function() {\r\n        var finder, selected_header, heuristic, allowDiagonal, biDirectional, dontCrossCorners, weight, trackRecursion, timeLimit;\r\n        \r\n        selected_header = $(\r\n            '#algorithm_panel ' +\r\n            '.ui-accordion-header[aria-selected=true]'\r\n        ).attr('id');\r\n        \r\n        switch (selected_header) {\r\n\r\n        case 'astar_header':\r\n            allowDiagonal = typeof $('#astar_section ' +\r\n                                     '.allow_diagonal:checked').val() !== 'undefined';\r\n            biDirectional = typeof $('#astar_section ' +\r\n                                     '.bi-directional:checked').val() !=='undefined';\r\n            dontCrossCorners = typeof $('#astar_section ' +\r\n                                     '.dont_cross_corners:checked').val() !=='undefined';\r\n\r\n            /* parseInt returns NaN (which is falsy) if the string can't be parsed */\r\n            weight = parseInt($('#astar_section .spinner').val()) || 1;\r\n            weight = weight >= 1 ? weight : 1; /* if negative or 0, use 1 */\r\n\r\n            heuristic = $('input[name=astar_heuristic]:checked').val();\r\n            if (biDirectional) {\r\n                finder = new PF.BiAStarFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners,\r\n                    heuristic: PF.Heuristic[heuristic],\r\n                    weight: weight\r\n                });\r\n            } else {\r\n                finder = new PF.AStarFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners,\r\n                    heuristic: PF.Heuristic[heuristic],\r\n                    weight: weight\r\n                });\r\n            }\r\n            break;\r\n\r\n        case 'breadthfirst_header':\r\n            allowDiagonal = typeof $('#breadthfirst_section ' +\r\n                                     '.allow_diagonal:checked').val() !== 'undefined';\r\n            biDirectional = typeof $('#breadthfirst_section ' +\r\n                                     '.bi-directional:checked').val() !== 'undefined';\r\n            dontCrossCorners = typeof $('#breadthfirst_section ' +\r\n                                     '.dont_cross_corners:checked').val() !=='undefined';\r\n            if (biDirectional) {\r\n                finder = new PF.BiBreadthFirstFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners\r\n                });\r\n            } else {\r\n                finder = new PF.BreadthFirstFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners\r\n                });\r\n            }\r\n            break;\r\n\r\n        case 'bestfirst_header':\r\n            allowDiagonal = typeof $('#bestfirst_section ' +\r\n                                     '.allow_diagonal:checked').val() !== 'undefined';\r\n            biDirectional = typeof $('#bestfirst_section ' +\r\n                                     '.bi-directional:checked').val() !== 'undefined';\r\n            dontCrossCorners = typeof $('#bestfirst_section ' +\r\n                                     '.dont_cross_corners:checked').val() !=='undefined';\r\n            heuristic = $('input[name=bestfirst_heuristic]:checked').val();\r\n            if (biDirectional) {\r\n                finder = new PF.BiBestFirstFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners,\r\n                    heuristic: PF.Heuristic[heuristic]\r\n                });\r\n            } else {\r\n                finder = new PF.BestFirstFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners,\r\n                    heuristic: PF.Heuristic[heuristic]\r\n                });\r\n            }\r\n            break;\r\n\r\n        case 'dijkstra_header':\r\n            allowDiagonal = typeof $('#dijkstra_section ' +\r\n                                     '.allow_diagonal:checked').val() !== 'undefined';\r\n            biDirectional = typeof $('#dijkstra_section ' +\r\n                                     '.bi-directional:checked').val() !=='undefined';\r\n            dontCrossCorners = typeof $('#dijkstra_section ' +\r\n                                     '.dont_cross_corners:checked').val() !=='undefined';\r\n            if (biDirectional) {\r\n                finder = new PF.BiDijkstraFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners\r\n                });\r\n            } else {\r\n                finder = new PF.DijkstraFinder({\r\n                    allowDiagonal: allowDiagonal,\r\n                    dontCrossCorners: dontCrossCorners\r\n                });\r\n            }\r\n            break;\r\n\r\n        case 'jump_point_header':\r\n            trackRecursion = typeof $('#jump_point_section ' +\r\n                                     '.track_recursion:checked').val() !== 'undefined';\r\n            heuristic = $('input[name=jump_point_heuristic]:checked').val();\r\n            \r\n            finder = new PF.JumpPointFinder({\r\n              trackJumpRecursion: trackRecursion,\r\n              heuristic: PF.Heuristic[heuristic],\r\n              diagonalMovement: PF.DiagonalMovement.IfAtMostOneObstacle\r\n            });\r\n            break;\r\n        case 'orth_jump_point_header':\r\n            trackRecursion = typeof $('#orth_jump_point_section ' +\r\n                                     '.track_recursion:checked').val() !== 'undefined';\r\n            heuristic = $('input[name=orth_jump_point_heuristic]:checked').val();\r\n\r\n            finder = new PF.JumpPointFinder({\r\n              trackJumpRecursion: trackRecursion,\r\n              heuristic: PF.Heuristic[heuristic],\r\n              diagonalMovement: PF.DiagonalMovement.Never\r\n            });\r\n            break;\r\n        case 'ida_header':\r\n            allowDiagonal = typeof $('#ida_section ' +\r\n                                     '.allow_diagonal:checked').val() !== 'undefined';\r\n            dontCrossCorners = typeof $('#ida_section ' +\r\n                                     '.dont_cross_corners:checked').val() !=='undefined';\r\n            trackRecursion = typeof $('#ida_section ' +\r\n                                     '.track_recursion:checked').val() !== 'undefined';\r\n\r\n            heuristic = $('input[name=jump_point_heuristic]:checked').val();\r\n\r\n            weight = parseInt($('#ida_section input[name=astar_weight]').val()) || 1;\r\n            weight = weight >= 1 ? weight : 1; /* if negative or 0, use 1 */\r\n\r\n            timeLimit = parseInt($('#ida_section input[name=time_limit]').val());\r\n\r\n            // Any non-negative integer, indicates \"forever\".\r\n            timeLimit = (timeLimit <= 0 || isNaN(timeLimit)) ? -1 : timeLimit;\r\n\r\n            finder = new PF.IDAStarFinder({\r\n              timeLimit: timeLimit,\r\n              trackRecursion: trackRecursion,\r\n              allowDiagonal: allowDiagonal,\r\n              dontCrossCorners: dontCrossCorners,\r\n              heuristic: PF.Heuristic[heuristic],\r\n              weight: weight\r\n            });\r\n\r\n            break;\r\n        }\r\n\r\n        return finder;\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pathfinding/node_modules/pathfinding/visual/js/view.js":"/**\r\n * The pathfinding visualization.\r\n * It uses raphael.js to show the grids.\r\n */\r\nvar View = {\r\n    nodeSize: 30, // width and height of a single node, in pixel\r\n    nodeStyle: {\r\n        normal: {\r\n            fill: 'white',\r\n            'stroke-opacity': 0.2, // the border\r\n        },\r\n        blocked: {\r\n            fill: 'grey',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n        start: {\r\n            fill: '#0d0',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n        end: {\r\n            fill: '#e40',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n        opened: {\r\n            fill: '#98fb98',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n        closed: {\r\n            fill: '#afeeee',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n        failed: {\r\n            fill: '#ff8888',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n        tested: {\r\n            fill: '#e5e5e5',\r\n            'stroke-opacity': 0.2,\r\n        },\r\n    },\r\n    nodeColorizeEffect: {\r\n        duration: 50,\r\n    },\r\n    nodeZoomEffect: {\r\n        duration: 200,\r\n        transform: 's1.2', // scale by 1.2x\r\n        transformBack: 's1.0',\r\n    },\r\n    pathStyle: {\r\n        stroke: 'yellow',\r\n        'stroke-width': 3,\r\n    },\r\n    supportedOperations: ['opened', 'closed', 'tested'],\r\n    init: function(opts) {\r\n        this.numCols      = opts.numCols;\r\n        this.numRows      = opts.numRows;\r\n        this.paper        = Raphael('draw_area');\r\n        this.$stats       = $('#stats');\r\n    },\r\n    /**\r\n     * Generate the grid asynchronously.\r\n     * This method will be a very expensive task.\r\n     * Therefore, in order to not to block the rendering of browser ui,\r\n     * I decomposed the task into smaller ones. Each will only generate a row.\r\n     */\r\n    generateGrid: function(callback) {\r\n        var i, j, x, y,\r\n            rect,\r\n            normalStyle, nodeSize,\r\n            createRowTask, sleep, tasks,\r\n            nodeSize    = this.nodeSize,\r\n            normalStyle = this.nodeStyle.normal,\r\n            numCols     = this.numCols,\r\n            numRows     = this.numRows,\r\n            paper       = this.paper,\r\n            rects       = this.rects = [],\r\n            $stats      = this.$stats;\r\n\r\n        paper.setSize(numCols * nodeSize, numRows * nodeSize);\r\n\r\n        createRowTask = function(rowId) {\r\n            return function(done) {\r\n                rects[rowId] = [];\r\n                for (j = 0; j < numCols; ++j) {\r\n                    x = j * nodeSize;\r\n                    y = rowId * nodeSize;\r\n\r\n                    rect = paper.rect(x, y, nodeSize, nodeSize);\r\n                    rect.attr(normalStyle);\r\n                    rects[rowId].push(rect);\r\n                }\r\n                $stats.text(\r\n                    'generating grid ' +\r\n                    Math.round((rowId + 1) / numRows * 100) + '%'\r\n                );\r\n                done(null);\r\n            };\r\n        };\r\n\r\n        sleep = function(done) {\r\n            setTimeout(function() {\r\n                done(null);\r\n            }, 0);\r\n        };\r\n\r\n        tasks = [];\r\n        for (i = 0; i < numRows; ++i) {\r\n            tasks.push(createRowTask(i));\r\n            tasks.push(sleep);\r\n        }\r\n\r\n        async.series(tasks, function() {\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        });\r\n    },\r\n    setStartPos: function(gridX, gridY) {\r\n        var coord = this.toPageCoordinate(gridX, gridY);\r\n        if (!this.startNode) {\r\n            this.startNode = this.paper.rect(\r\n                coord[0],\r\n                coord[1],\r\n                this.nodeSize,\r\n                this.nodeSize\r\n            ).attr(this.nodeStyle.normal)\r\n             .animate(this.nodeStyle.start, 1000);\r\n        } else {\r\n            this.startNode.attr({ x: coord[0], y: coord[1] }).toFront();\r\n        }\r\n    },\r\n    setEndPos: function(gridX, gridY) {\r\n        var coord = this.toPageCoordinate(gridX, gridY);\r\n        if (!this.endNode) {\r\n            this.endNode = this.paper.rect(\r\n                coord[0],\r\n                coord[1],\r\n                this.nodeSize,\r\n                this.nodeSize\r\n            ).attr(this.nodeStyle.normal)\r\n             .animate(this.nodeStyle.end, 1000);\r\n        } else {\r\n            this.endNode.attr({ x: coord[0], y: coord[1] }).toFront();\r\n        }\r\n    },\r\n    /**\r\n     * Set the attribute of the node at the given coordinate.\r\n     */\r\n    setAttributeAt: function(gridX, gridY, attr, value) {\r\n        var color, nodeStyle = this.nodeStyle;\r\n        switch (attr) {\r\n        case 'walkable':\r\n            color = value ? nodeStyle.normal.fill : nodeStyle.blocked.fill;\r\n            this.setWalkableAt(gridX, gridY, value);\r\n            break;\r\n        case 'opened':\r\n            this.colorizeNode(this.rects[gridY][gridX], nodeStyle.opened.fill);\r\n            this.setCoordDirty(gridX, gridY, true);\r\n            break;\r\n        case 'closed':\r\n            this.colorizeNode(this.rects[gridY][gridX], nodeStyle.closed.fill);\r\n            this.setCoordDirty(gridX, gridY, true);\r\n            break;\r\n        case 'tested':\r\n            color = (value === true) ? nodeStyle.tested.fill : nodeStyle.normal.fill;\r\n\r\n            this.colorizeNode(this.rects[gridY][gridX], color);\r\n            this.setCoordDirty(gridX, gridY, true);\r\n            break;\r\n        case 'parent':\r\n            // XXX: Maybe draw a line from this node to its parent?\r\n            // This would be expensive.\r\n            break;\r\n        default:\r\n            console.error('unsupported operation: ' + attr + ':' + value);\r\n            return;\r\n        }\r\n    },\r\n    colorizeNode: function(node, color) {\r\n        node.animate({\r\n            fill: color\r\n        }, this.nodeColorizeEffect.duration);\r\n    },\r\n    zoomNode: function(node) {\r\n        node.toFront().attr({\r\n            transform: this.nodeZoomEffect.transform,\r\n        }).animate({\r\n            transform: this.nodeZoomEffect.transformBack,\r\n        }, this.nodeZoomEffect.duration);\r\n    },\r\n    setWalkableAt: function(gridX, gridY, value) {\r\n        var node, i, blockedNodes = this.blockedNodes;\r\n        if (!blockedNodes) {\r\n            blockedNodes = this.blockedNodes = new Array(this.numRows);\r\n            for (i = 0; i < this.numRows; ++i) {\r\n                blockedNodes[i] = [];\r\n            }\r\n        }\r\n        node = blockedNodes[gridY][gridX];\r\n        if (value) {\r\n            // clear blocked node\r\n            if (node) {\r\n                this.colorizeNode(node, this.rects[gridY][gridX].attr('fill'));\r\n                this.zoomNode(node);\r\n                setTimeout(function() {\r\n                    node.remove();\r\n                }, this.nodeZoomEffect.duration);\r\n                blockedNodes[gridY][gridX] = null;\r\n            }\r\n        } else {\r\n            // draw blocked node\r\n            if (node) {\r\n                return;\r\n            }\r\n            node = blockedNodes[gridY][gridX] = this.rects[gridY][gridX].clone();\r\n            this.colorizeNode(node, this.nodeStyle.blocked.fill);\r\n            this.zoomNode(node);\r\n        }\r\n    },\r\n    clearFootprints: function() {\r\n        var i, x, y, coord, coords = this.getDirtyCoords();\r\n        for (i = 0; i < coords.length; ++i) {\r\n            coord = coords[i];\r\n            x = coord[0];\r\n            y = coord[1];\r\n            this.rects[y][x].attr(this.nodeStyle.normal);\r\n            this.setCoordDirty(x, y, false);\r\n        }\r\n    },\r\n    clearBlockedNodes: function() {\r\n        var i, j, blockedNodes = this.blockedNodes;\r\n        if (!blockedNodes) {\r\n            return;\r\n        }\r\n        for (i = 0; i < this.numRows; ++i) {\r\n            for (j = 0 ;j < this.numCols; ++j) {\r\n                if (blockedNodes[i][j]) {\r\n                    blockedNodes[i][j].remove();\r\n                    blockedNodes[i][j] = null;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    drawPath: function(path) {\r\n        if (!path.length) {\r\n            return;\r\n        }\r\n        var svgPath = this.buildSvgPath(path);\r\n        this.path = this.paper.path(svgPath).attr(this.pathStyle);\r\n    },\r\n    /**\r\n     * Given a path, build its SVG represention.\r\n     */\r\n    buildSvgPath: function(path) {\r\n        var i, strs = [], size = this.nodeSize;\r\n\r\n        strs.push('M' + (path[0][0] * size + size / 2) + ' ' +\r\n                  (path[0][1] * size + size / 2));\r\n        for (i = 1; i < path.length; ++i) {\r\n            strs.push('L' + (path[i][0] * size + size / 2) + ' ' +\r\n                      (path[i][1] * size + size / 2));\r\n        }\r\n\r\n        return strs.join('');\r\n    },\r\n    clearPath: function() {\r\n        if (this.path) {\r\n            this.path.remove();\r\n        }\r\n    },\r\n    /**\r\n     * Helper function to convert the page coordinate to grid coordinate\r\n     */\r\n    toGridCoordinate: function(pageX, pageY) {\r\n        return [\r\n            Math.floor(pageX / this.nodeSize),\r\n            Math.floor(pageY / this.nodeSize)\r\n        ];\r\n    },\r\n    /**\r\n     * helper function to convert the grid coordinate to page coordinate\r\n     */\r\n    toPageCoordinate: function(gridX, gridY) {\r\n        return [\r\n            gridX * this.nodeSize,\r\n            gridY * this.nodeSize\r\n        ];\r\n    },\r\n    showStats: function(opts) {\r\n        var texts = [\r\n            'length: ' + Math.round(opts.pathLength * 100) / 100,\r\n            'time: ' + opts.timeSpent + 'ms',\r\n            'operations: ' + opts.operationCount\r\n        ];\r\n        $('#stats').show().html(texts.join('<br>'));\r\n    },\r\n    setCoordDirty: function(gridX, gridY, isDirty) {\r\n        var x, y,\r\n            numRows = this.numRows,\r\n            numCols = this.numCols,\r\n            coordDirty;\r\n\r\n        if (this.coordDirty === undefined) {\r\n            coordDirty = this.coordDirty = [];\r\n            for (y = 0; y < numRows; ++y) {\r\n                coordDirty.push([]);\r\n                for (x = 0; x < numCols; ++x) {\r\n                    coordDirty[y].push(false);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.coordDirty[gridY][gridX] = isDirty;\r\n    },\r\n    getDirtyCoords: function() {\r\n        var x, y,\r\n            numRows = this.numRows,\r\n            numCols = this.numCols,\r\n            coordDirty = this.coordDirty,\r\n            coords = [];\r\n\r\n        if (coordDirty === undefined) {\r\n            return [];\r\n        }\r\n\r\n        for (y = 0; y < numRows; ++y) {\r\n            for (x = 0; x < numCols; ++x) {\r\n                if (coordDirty[y][x]) {\r\n                    coords.push([x, y]);\r\n                }\r\n            }\r\n        }\r\n        return coords;\r\n    },\r\n};\r\n"}